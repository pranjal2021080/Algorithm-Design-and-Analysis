

---

# ğŸ“˜ Algorithm Design and Analysis

This repository presents a structured collection of algorithmic problem-solving work focused on **design paradigms, rigorous analysis, and correct formulation of computational problems**.
Each section demonstrates how complex problems are transformed into precise algorithmic models and solved with provable efficiency.

The repository emphasizes:

* Clear **problem formulation**
* Correct use of **algorithmic paradigms**
* Step-by-step **reasoning and justification**
* Precise **time-complexity analysis**

---

## ğŸ§­ Repository Organization

The repository is organized by **algorithmic themes**, not by assignment numbers.
Each folder represents a **core idea in algorithm design** and contains:

* ğŸ“„ **Assignment_Documentation.pdf** â€“ the original problem statements
* ğŸ“„ **Assignment_Solutions.pdf** â€“ complete, well-structured solutions

```
Algorithm-Design-and-Analysis
â”‚
â”œâ”€â”€ Divide_and_Conquer_and_Dynamic_Programming
â”‚
â”œâ”€â”€ Graph_Algorithms_and_Probabilistic_Analysis
â”‚
â””â”€â”€ Network_Flow_and_Min_Cut_Applications
```

This structure allows a reader to immediately understand **what concept is being addressed** and **how it is solved**.

---

## ğŸ§© Assignment 1

## Divide and Conquer and Dynamic Programming

This section focuses on two foundational algorithm design paradigms:

### ğŸ”¹ Divide and Conquer

Problems are decomposed into smaller independent subproblems, solved recursively, and combined efficiently.

**Example addressed in this assignment:**

* Tiling an ( n \times n ) board with one defective square using L-shaped tiles
* Recursive decomposition into quadrants
* Justification of correctness and runtime

---

### ğŸ”¹ Dynamic Programming

Problems are solved by identifying overlapping subproblems and building solutions incrementally using recurrence relations.

**Key elements emphasized:**

* Subproblem definition
* Recurrence formulation
* Identification of base cases
* Efficient evaluation order
* Precise runtime analysis

**Problems include:**

* Selecting intersecting line segments
* Cost-optimal scheduling across weeks

---

### ğŸ“ Folder Contents

* **Assignment_Documentation.pdf**
  Original problem descriptions and instructions

* **Assignment_Solutions.pdf**
  Detailed solutions including:

  * Subproblem definitions
  * Recurrences
  * Algorithm descriptions
  * Time-complexity arguments

---

## ğŸ§  Assignment 2

## Graph Algorithms and Probabilistic Analysis

This section demonstrates how real-world constraints are modeled using **graph theory** and solved using **linear-time algorithms**.

---

### ğŸ”¹ Graph Connectivity and Reachability

Problems are modeled as directed or undirected graphs to analyze:

* Strong connectivity
* Reachability under constraints
* Existence of return paths

**Techniques used:**

* Graph formulation
* DFS / BFS
* Structural graph properties

---

### ğŸ”¹ Cycle Detection in Sparse Graphs

The assignment includes identifying:

* Edges participating in cycles
* Minimum-weight edges inside cycles
* Linear-time solutions despite weighted edges

---

### ğŸ”¹ Probabilistic Computation on DAGs

Random walks on directed acyclic graphs are analyzed by:

* Modeling probabilities on edges
* Computing sink reachability probabilities
* Using topological order and dynamic programming

---

### ğŸ“ Folder Contents

* **Assignment_Documentation.pdf**
  Complete problem statements

* **Assignment_Solutions.pdf**
  Includes:

  * Graph construction explanations
  * Algorithm descriptions
  * Correctness reasoning
  * Runtime justification

---

## ğŸŒŠ Assignment 3

## Network Flow and Min-Cut Applications

This section focuses on **flow networks** and the **max-flow min-cut principle**.

---

### ğŸ”¹ Flow Network Modeling

A real-world separation problem is converted into:

* A directed flow network
* Carefully defined edge capacities
* Source and sink construction

---

### ğŸ”¹ Minimum Cut Interpretation

The solution relies on the equivalence between:

* Minimum number of edges to remove
* Minimum cut separating two vertices

This demonstrates how **abstract theorems** directly solve **practical optimization problems**.

---

### ğŸ“ Folder Contents

* **Assignment_Documentation.pdf**
  Problem description and constraints

* **Assignment_Solutions.pdf**
  Includes:

  * Network construction
  * Use of max-flow / min-cut theorem
  * Algorithm description
  * Polynomial-time analysis

---

## ğŸ” Design Principles Followed

âœ” Concept-based organization
âœ” Clear separation of problems and solutions
âœ” Emphasis on reasoning, not code
âœ” Explicit runtime justification
âœ” Precise mathematical formulation

Each solution is written to be **readable, verifiable, and logically complete**.

---

## ğŸ“Œ How to Navigate This Repository

1. Choose a folder based on the algorithmic concept
2. Read **Assignment_Documentation.pdf** to understand the problem
3. Read **Assignment_Solutions.pdf** for the complete solution
4. Follow the flow from formulation â†’ algorithm â†’ analysis

---

## ğŸ Closing Note

This repository demonstrates a systematic approach to algorithm design, showing how complex problems are solved through **structured thinking, careful modeling, and efficient algorithms**.

It serves as a clear record of work across:

* Divide and conquer
* Dynamic programming
* Graph traversal
* Probabilistic computation
* Network flow theory

---

